---
layout: post
title: 软件配置管理
category: technology
tag: software
---

# 软件配置管理


注: 以下只是不负责任的开脑洞, 没有在生产环境中实践过.

一个良好组织过的代码仓库, 需要将配置从仓库中分离.
代码中只需要根据配置项就能获得值.

常见的配置有两种, 不知有无更好的方案:

* 环境变量
  * 优点是选项正交, 无需类库依赖, 系统提供支持;
  * 缺点是没有版本控制, 没有命名空间.

* 分组(dev,test,prod)
  * 优点是有版本控制, 命名空间;
  * 缺点是会组合爆炸.

综合下: 理想中的配置管理应该做到:

* 配置与代码分离
* 配置有命名空间
* 配置多版本, 多组别, 可根据特定环境自定义


## 配置与代码分离

我们先从代码仓库的使用来思考问题.
应用程序屏蔽配置的实现细节.
应用程序只需要可以通过 `命名空间 + 配置项` 获取到需要的值,
这需要我们在实现一个接口 (define (get-env ns key)).
该接口从 ENV 中读取值.

我们希望配置可以被写到环境变量中的.
环境变量本身并不能被版本管理 (除非你用GitFS).
但可用的方案是用版本管理的仓库管理配置, 再将配置写到环境变量中.
说起来有些绕口, 应用程序不直接依赖于配置的仓库, 而依赖于配置仓库写入环境变量的结果.
这是一种语言无关, 细节屏蔽的手段.

所以, 上面的方案在持续集成中的步骤是:

* 下载配置仓库
* 运行配置仓库的main, 将仓库的所有配置写到环境变量中
* 下载安装代码仓库
* 直接运行代码仓库的实例.


## 命名空间

环境变量是扁平的, 本身并无命名空间.
但我们可以制定命名规则添加前缀.

例如每级命名空间用两个下划线分隔:
`vanilla.database.connect_param` 对应的环境变量名则是 `VANILLA__DATABASE__CONNECT_PARAM`.

这或许需要我们在将配置变量前做一次命名检查, 一个变量名不能有两个下划线.
即便有这样的限制, 我们仍然觉得它是可接受的.

当然, 可以有更多的规则, 这取决于程序员们的偏好.
一个更加稳妥的办法, 是编写类似 `clojure.core/munge` 这样的映射函数.

## 命名空间与多版本

命名空间亦可用作版本隔离.

让我们假设 Bob 要开始触发上线了.
主干的稳定代码要被部署到线上.
然而, 他不能冒冒失失的将主干代码直接部署.
因为主干代码需要的新的配置项.
而目前Heroku的环境变量还是旧的.

他决定用命名空间做分隔.
生产环境Heroku上运行的代码使用 `production_7d74032` 作为配置的命名空间.
预发布环境使用 `prerelease_7d74032` 作为命名空间.

上线前, Bob 将 `prerelease_d786b24` 作为预发布服务器的命名空间, 写入配置.
现在, 他将代码部署到预发布服务器, 新代码使用 `prerelease_d786b24` 读取配置.

核查发现问题, Bob 回滚预发布环境的代码, 并以 `prerelease_7d74032` 为命名空间读取配置.

修复核查后没有发现问题, 接着, Bob 触发了上线.
持续集成为生成环境服务器写入命名空间为 `online_d786b24` 的配置.
紧接着更新了代码, 以 `online_d786b24` 为命名空间重启了服务.

由于 Bob 将遗留配置的数量设置为3, 各处的环境变量没有越积越多.

## 多组别

为几个固定的环境分组写配置.
常见的组别: dev, prod, staging, qaci 等等.

## DRY

配置项很容易产生重复代码:

    - mc
      - localhost:11211
      - localhost:11212
      - localhost:11213
      - localhost:11214
      - localhost:11215
    - db
      - localhost:7878
      - localhost:7979

对于 DRY 有强烈执念的我们, 必然想到了抽象.
使用过程参与配置, 一堆配置过程组合成的最终过程, 输出即为结果.
这给我们更强大的能力来控制我们的配置输出:

    localhost = lambda { |port| "localhost:#{port}" }

    mc = (11211..11215).map &localhost
    db = [7878, 7979].map &localhost


## Docker

Docker 的出现, 几乎消弭了环境之间的差异.
开发环境可以和生产环境配置相同.
也许未来, 软件配置会成为一个古董技术?!
